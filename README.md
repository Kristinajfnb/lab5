# Лабораторная работа №3. Основы работы с базами данных в Laravel

## Цель работы

Познакомиться с основными принципами работы с базами данных в Laravel. Научиться создавать миграции, модели и сиды на основе веб-приложения `To-Do App`.

### Задания

1. Использую Sqlite.
2. Создаем новую базу данных для приложения **todo_app**.
3. Настраиваем переменные окружения в файле `.env` для подключения к базе данных:

![Ку](images/1.jpg)

4. Создаем модель `Category` — категория задачи.
   - `php artisan make:model Category -m`
5. Определяем структуры таблицы **category** в миграции:

```php
      public function up()
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->id(); // первичный ключ
            $table->string('name'); // название категории
            $table->text('description')->nullable(); // описание категории
            $table->timestamps(); // created_at и updated_at
        });
    }
```

6. Создаем модель `Task` — задача.
- `php artisan make:model Task –m`
7. Определяем структуры таблицы **task** в миграции:

```php
public function up()
    {
        Schema::create('tasks', function (Blueprint $table) {
            $table->id(); // первичный ключ
            $table->string('title'); // название задачи
            $table->text('description')->nullable(); // описание задачи
            $table->timestamps(); // created_at и updated_at
        });
    }
```
8. Запускаем миграцию для создания таблицы в базе данных:

![Ку](images/2.jpg)

9. Создаем модель `Tag` — тег задачи.

- `php artisan make:model Tag –m`

10. Определяем структуры таблицы **tag** в миграции:

```php
  public function up()
    {
        Schema::create('tags', function (Blueprint $table) {
            $table->id(); // первичный ключ
            $table->string('name'); // название тега
            $table->timestamps(); // created_at и updated_at
        });
    }
```
11. Добавьте поле `$fillable` в модели `Task`, `Category` и `Tag` для массового заполнения данных.

```php
protected $fillable = ['name', 'description']; // поля для массового заполнения
```

12. Создаем миграцию для добавления поля `category_id` в таблицу **task**.
   - `php artisan make:migration add_category_id_to_tasks_table --table=tasks`
   - Определяем структуру поля `category_id` и добавляем внешний ключ для связи с таблицей **category**.

   ```php
   public function up()
    {
        Schema::table('tasks', function (Blueprint $table) {
            $table->unsignedBigInteger('category_id')->after('id'); // добавление поля category_id
            // Установка внешнего ключа
            $table->foreign('category_id')
                  ->references('id')
                  ->on('categories')
                  ->onDelete('cascade'); // удаление задачи при удалении категории
        });
    }
    ```

13. Создаем промежуточную таблицу для связи многие ко многим между задачами и тегами:
   - `php artisan make:migration create_task_tag_table`
14. Определение соответствующей структуры таблицы в миграции.

```php
   public function up()
    {
        Schema::create('task_tag', function (Blueprint $table) {
            $table->id(); // автоинкрементный первичный ключ
            $table->unsignedBigInteger('task_id'); // внешний ключ на таблицу tasks
            $table->unsignedBigInteger('tag_id'); // внешний ключ на таблицу tags

            // Установка внешних ключей
            $table->foreign('task_id')
                  ->references('id')
                  ->on('tasks')
                  ->onDelete('cascade'); // удаление связи при удалении задачи

            $table->foreign('tag_id')
                  ->references('id')
                  ->on('tags')
                  ->onDelete('cascade'); // удаление связи при удалении тега
        });
    }
```
15. Запускаем миграцию для создания таблицы в базе данных.

- `php artisan migrate`

16. Добавляем отношения в модель `Category`

     ```php
     public function tasks()
     {
         return $this->hasMany(Task::class);
     }
     ```

17. Добавляем отношения в модель `Task`.

 ```php
class Task extends Model
{
    use HasFactory;

    protected $fillable = ['title', 'description', 'category_id']; // Добавьте поле для массового заполнения

    // Метод для связи с категорией
    public function category()
    {
        return $this->belongsTo(Category::class); // Одна задача принадлежит одной категории
    }

    // Метод для связи с тегами
    public function tags()
    {
        return $this->belongsToMany(Tag::class, 'task_tag'); // Задача может иметь много тегов
    }
}
 ```
   
18. Добавляем отношения в модель `Tag`.

 ```php
class Tag extends Model
{
    use HasFactory;

    protected $fillable = ['name']; // Добавьте поле для массового заполнения

    // Метод для связи с задачами
    public function tasks()
    {
        return $this->belongsToMany(Task::class, 'task_tag'); // Тег может быть прикреплен к многим задачам
    }
}
 ```

19. Добавляем соотвтествующие поля в `$fillable` моделей.
20. Создаем фабрику для модели `Category`:
   - `php artisan make:factory CategoryFactory --model=Category`
   - Определяем структуру данных для генерации категорий.

    ```php
   public function definition()
    {
        return [
            'name' => $this->faker->word, // Генерация случайного названия категории
            'description' => $this->faker->sentence, // Генерация случайного описания
        ];
    }
    ```

21. Создаем фабрику для модели `Task`.
- `php artisan make:factory TaskFactory --model=Task`
22. Создаем фабрику для модели `Tag`.
- `php artisan make:factory TagFactory --model=Tag`
23. Создаем сиды (`seeders`) для заполнения таблиц начальными данными для моделей: `Category`, `Task`, `Tag`.
- `php artisan make:seeder CategorySeeder`
- `php artisan make:seeder TaskSeeder`
- `php artisan make:seeder TagSeeder`

24. Обновляем файл `DatabaseSeeder` для запуска сидов и запускаем их:
   ```bash
   php artisan db:seed
   ```
![Ку](images/3.jpg)

25. Открываем контроллер `TaskController` (`app/Http/Controllers/TaskController.php`).
26. Обновляем методы `index`, `Task`,  `show`, `index`, `show`, `destroy`, `edit`, `update`, `create`, `store`.
27. Обновляем соответствующие представления для отображения списка задач и отдельной задачи.

![Ку](images/4.jpg)

![Ку](images/6.jpg)

![Ку](images/6.jpg)

## Контрольные вопросы

1. Что такое миграции  и для чего они используются? Миграции — это способ версионирования и управления схемой базы данных в приложениях на Laravel. Они позволяют разработчикам создавать, изменять и удалять таблицы и поля базы данных, сохраняя при этом историю изменений. Основные преимущества миграций: Безопасность: Миграции позволяют откатить изменения при необходимости. Удобство: Разработчики могут легко делиться структурой базы данных через систему контроля версий. Автоматизация: Миграции можно выполнять через командную строку, что упрощает процесс развертывания.
2. Что такое фабрики и сиды, и как они упрощают процесс разработки и тестирования? Фабрики и сиды в Laravel используются для упрощения генерации и заполнения тестовыми данными: Фабрики (Factories) позволяют создавать объекты модели с фейковыми данными для тестирования. Они помогают быстро заполнять базу данных данными без необходимости вручную вводить каждую запись. Сиды (Seeders) — это классы, которые содержат код для заполнения таблиц базы данных начальными данными. С их помощью можно быстро и удобно заполнить базу данных фиксированными данными, что полезно для разработки и тестирования. Вместе они позволяют разработчикам быстро создавать тестовые данные и проверять функциональность приложения.
3. Что такое ORM? В чем различия между паттернами `DataMapper` и `ActiveRecord`? ORM (Object-Relational Mapping) — это метод программирования, который позволяет взаимодействовать с базой данных, используя объекты вместо прямых SQL-запросов. Это упрощает работу с данными, делая код более читаемым и удобным. ActiveRecord: Каждая модель представляет собой таблицу в базе данных, а объекты модели напрямую связаны с записями. Методы для выполнения запросов и управления состоянием объекта находятся в одной модели. DataMapper: В этом паттерне модель и база данных отделены. Модель не знает о том, как сохраняются и загружаются данные, и методы доступа к данным (например, репозитории) используются для взаимодействия. 
4. В чем преимущества использования ORM по сравнению с прямыми SQL-запросами? Удобство работы: ORM позволяет работать с базой данных, используя объекты, что делает код более понятным и легким для чтения.
Безопасность: ORM автоматически обрабатывает экранирование данных, что помогает предотвратить SQL-инъекции.
Мобильность: Код, использующий ORM, более независим от конкретной СУБД, что упрощает переход на другую СУБД.
Упрощение тестирования: ORM позволяет легче подменять реализацию доступа к данным во время тестирования, что упрощает тестирование бизнес-логики.
5. Что такое транзакции и зачем они нужны при работе с базами данных? Транзакции — это группа операций, которые выполняются как единое целое. Транзакции обеспечивают целостность данных, гарантируя, что либо все операции в транзакции будут выполнены успешно, либо ни одна из них не будет применена. Использование транзакций помогает предотвратить повреждение данных и обеспечивает надежность работы с базой данных.